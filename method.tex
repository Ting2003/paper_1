\section{Methodology}
  \subsection{Sparse Vector}
   %first show the example and cite%
    There are two stages in solving a linear system: matrix decomposition and forward (FE) and backward (BE) substitution. In matrix 
decomposition stage, the sparsity feature of matrix can greatly help reducing computation intensity. In the same way, the sparsity of 
vectors can help reducing the computation intensity in the FE and BE substitution stage. \cite{Tinney} illustrates the sparse vector 
method. Suppose we have a linear system with 20 nodes. The conductance matrix has already been decomposed, which is 
\begin{equation}
	A=LL'\label{eq3.1}
\end{equation}
Forward and backward substitution are required to obtain the final solution. The equations for these two operations are as follows:
\begin{align}
	LY &=b  &(FE)\label{eq3.2}\\
	L'X &= Y&(BE)\label{eq3.3}
\end{align}

%figure 1: elimination tree of A%
Figure 1 Shows the $L$ of the decomposed matrix $A$ and the corresponding elimination tree. Assuming that only $y_{12}, y_{14}$ is 
non-zero, and only solution of $x_{10}$ and $x_{17}$ are required to be obtained. The items in $Y$ and $X$ that need to be computed can be 
presented along the order of paths listed as follows:
\begin{align}
&\{12, 15, 14, 17, 18, 19, 20\} &(FE)\label{eq3.4}\\
&\{20, 19, 18, 17, 13, 10\}&(BE)\label{eq3.5}
\end{align}
In this paper, we define the above two paths as ``forward path" and ``backward path". By utilizing the sparse characteristic of vectors,
only 6 or 7 items are needed to compute instead of 20. It can be seen that by utilizing the sparsity characteristic of vectors, a lot of
savings in FE and BE substitution process can be obtained. The amount of savings in computation depends on the number of nodes in the 
paths, which is decided by the structure of decomposed matrix. 
 
There are two parts of nodes' voltage values we need to obtain in each time step. First, in transient analysis, as long as the equivalent parameters of capacitors and inductances are obtained, we can perform 
simulation of next time step. Considering the equations for equivalent parameters of capacitances and inductances, which is shown in %equations shown the equivalent values for cap and inducs%.

As a result, the voltage values of neighboring nodes of capacitor and inductance should be 
known to obtain $V(t)$ and $i(t)$ from last step. Besides, there are tens nodes listed in the output list of the netlist, whose voltage values change we are interested. The voltage values of
these two sets of nodes are all information we need to get at each time step. Considering that these two sets of nodes only occupies a
tiny part of the total number of nodes in power grid, the equivalent
vector $X$ is very sparse. On the other hand, number of non-zeros in $b$ depends on the number of current sources in the grid, which is 
very a small ratio of the total number of nodes in the grid. $b$ is very sparse as well. With the sparse vector $b$ and $X$, we can build 
the forward and backward paths and save a lot of effort in FE and BE substitution process. This effort is worthwhile for transient 
analysis, because the built paths can be reused along the time steps, thus time saving is accumulated as time step goes by.

The critical task now is to build the forward and backward paths. \cite{Tinney} provides a path building method, where the first path is 
obtained on the first step. Then, the next path segments will be inserted into the original path as a whole unit. The inserting point is 
before the cross point of new path segment and original one. The resulting path is shown in equation \eqref{eq3.4} and \eqref{eq3.5}. It
can be seen that the resulting index of rows/columns in the path is not monotone ascending or descending. This will cause trouble in
later substitution stage, because it is not possible to finish traversing the path with a single for loop. In order to reduce the 
complexity, the indexes in the path have to be in monotone ascending order in FF and in monotone descending order in BF. Another more 
serious problem is that this method can not detect the case where a node does not have any decedent in the elimination tree, such as column $5$ in figure 1. Because diagonal element does not have any decedent element, no insertion point can be find with the above method. As a result, the built path is incomplete, and will lead to wrong results. 

In order to overcome the above limitations, a new method is proposed in this paper. It is illustrated in Figure 2.
%Figure 2: showing the algorithms of path building method%
After building the first path, the next segment start from the node with minimum index and will stop under two cases: 
\begin{enumerate}[1)]
\item Current node has a descendent and the descendent node is already in the formed path; 
\item Current node has no descendent.
\end{enumerate} 
The second step insures node that has no descendent is inserted in the path. We build a list to record all the nodes in 
the segments. To make the later substitution stage being finished in a single traversing, we sorted the nodes in the list. The sorted list are then inserted into the original path obtained from first step. Since the nodes in the list are in monotone ascending or descending order, which is in accordance with the original path, the searching and insertion point starts from the position that the last node is inserted, instead of the head of the path. The cost for the total searching and insertion operations is $O(n)$, where $n$ is the number of nodes in 
the matrix. Notice that we only sort the array with length of the segments instead of all the nodes in the matrix. If the first path is 
very long, we only need to sort very short array, which reduces a lot of effort.
%In the experiment result, need a table to show the ratio saved with this technique, and the speed for building the paths% 

 \subsection{Solution Mapping}
In order to reduce fill-ins, reordering is usually utilized in matrix decomposition stage. The ordering of nodes' indexes in decomposed 
matrix and the original matrix are different. In the FE and BE substitution stage, corresponding reordering must 
be performed to the right hand side vector to get the right result. Regular solving process is as follows:
\begin{enumerate}[1)]
\item Reordering the right hand side vector in the same pattern as matrix decomposition stage.
\item Perform forward and backward substitution to get the reordered solution.
\item Reordering the solved vector back in the inverse pattern as that of the right hand side.
\end{enumerate}
As we can see, in each time step, 2 reordering operations are required to get the right solution. If we utilize the regular solving 
process in each time step, for transient analysis of large power grid, the reordering process may cost a lot of extra time. It is highly preferable to eliminate the reordering operation. In this paper, we propose a smart mapping technique to avoid these reordering operations.

After factorizing the conductance matrix, the index relationship of each node between the original matrix and decomposed matrix is recorded. For each node in power grid, instead of keeping the original index, we renew the index into the new one. We also re-stamp the right hand side based on the new index of nodes. These process is only performed in the first time step for once. The updated indexes will be maintained in the rest of the time steps. Through these operations, the right hand side vector is
in the same ordering with the decomposed matrix. The equivalent linear system for solving stage is as follows:
\begin{equation}
A'x = b'
\end{equation}
where $A'=LL'$ is the decomposed matrix without reordering, and $b'$ is the right hand side without reordering.

By performing the above operations, we successfully eliminate the reordering operation along the time steps.
%In Experiment result, need a table to show the time savings with the reordering technique% 

  \subsection{Memory Supernode Solving}
%find and cite some papers about supernode technique, a brief introduction of supernode solving%
%need to talk about regular supernode solving process: judgement is required to be performed in each time step%
In this paper, a modified supernode technique named ``Memory Supernode Solving" is proposed for efficient transient simulation. After 
factorizing the conductance matrix, the number of columns contained in each supernode is gained by judging the characteristic among 
neighboring columns. This information is stored in an array. Then, in each time step, corresponding functions for different type of 
supernode are directly called by getting data from the stored array. No complex judgement is required. This is effective for transient
analysis, in which multi step computation is required.  
%In experiment result, need a table to show the time savings with Memorized supernode solving technique%
  \subsection{Optimized Current Restamping}
In transient analysis, current varies among different time steps. Because of this change, vector $b$ in equation $AX=b$ needs to be 
modified at different time steps. It should be noticed that part of the currents stay static for a period. We do not need to modify
the items that correspond to these current sources. Instead, in each time step, we will locate those current sources whose value are
different from last step, and only modify the corresponding items in the right hand side. 
  \subsection{Multiple threads}
There are usually several sub circuits in power grids: VDD, GND and so on. These sub circuits are totally disjoint and can be solved
in parallel. In this paper, multiple threads are used to parallelize the simulation. One thread handles one sub circuit. The number of
speed up is almost identical to the number of sub circuits in the power grids.
%talking about dynamic schedule, and why further speed up can not gained with this stra